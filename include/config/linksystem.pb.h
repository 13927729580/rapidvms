// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: linksystem.proto

#ifndef PROTOBUF_linksystem_2eproto__INCLUDED
#define PROTOBUF_linksystem_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "vidconf.pb.h"
// @@protoc_insertion_point(includes)
class LinkCamReq;
class LinkCamReqDefaultTypeInternal;
extern LinkCamReqDefaultTypeInternal _LinkCamReq_default_instance_;
class LinkCamResp;
class LinkCamRespDefaultTypeInternal;
extern LinkCamRespDefaultTypeInternal _LinkCamResp_default_instance_;
class LinkKeepaliveReq;
class LinkKeepaliveReqDefaultTypeInternal;
extern LinkKeepaliveReqDefaultTypeInternal _LinkKeepaliveReq_default_instance_;
class LinkKeepaliveResp;
class LinkKeepaliveRespDefaultTypeInternal;
extern LinkKeepaliveRespDefaultTypeInternal _LinkKeepaliveResp_default_instance_;
class LinkListCamReq;
class LinkListCamReqDefaultTypeInternal;
extern LinkListCamReqDefaultTypeInternal _LinkListCamReq_default_instance_;
class LinkListCamResp;
class LinkListCamRespDefaultTypeInternal;
extern LinkListCamRespDefaultTypeInternal _LinkListCamResp_default_instance_;
class LinkLoginReq;
class LinkLoginReqDefaultTypeInternal;
extern LinkLoginReqDefaultTypeInternal _LinkLoginReq_default_instance_;
class LinkLoginResp;
class LinkLoginRespDefaultTypeInternal;
extern LinkLoginRespDefaultTypeInternal _LinkLoginResp_default_instance_;
class VidBlob;
class VidBlobDefaultTypeInternal;
extern VidBlobDefaultTypeInternal _VidBlob_default_instance_;
class VidBlobList;
class VidBlobListDefaultTypeInternal;
extern VidBlobListDefaultTypeInternal _VidBlobList_default_instance_;
class VidCamera;
class VidCameraDefaultTypeInternal;
extern VidCameraDefaultTypeInternal _VidCamera_default_instance_;
class VidCameraId;
class VidCameraIdDefaultTypeInternal;
extern VidCameraIdDefaultTypeInternal _VidCameraId_default_instance_;
class VidCameraList;
class VidCameraListDefaultTypeInternal;
extern VidCameraListDefaultTypeInternal _VidCameraList_default_instance_;
class VidClientConf;
class VidClientConfDefaultTypeInternal;
extern VidClientConfDefaultTypeInternal _VidClientConf_default_instance_;
class VidDisk;
class VidDiskDefaultTypeInternal;
extern VidDiskDefaultTypeInternal _VidDisk_default_instance_;
class VidDiskList;
class VidDiskListDefaultTypeInternal;
extern VidDiskListDefaultTypeInternal _VidDiskList_default_instance_;
class VidEmap;
class VidEmapDefaultTypeInternal;
extern VidEmapDefaultTypeInternal _VidEmap_default_instance_;
class VidEmapCamera;
class VidEmapCameraDefaultTypeInternal;
extern VidEmapCameraDefaultTypeInternal _VidEmapCamera_default_instance_;
class VidEmapList;
class VidEmapListDefaultTypeInternal;
extern VidEmapListDefaultTypeInternal _VidEmapList_default_instance_;
class VidEvent;
class VidEventDefaultTypeInternal;
extern VidEventDefaultTypeInternal _VidEvent_default_instance_;
class VidEventDBConf;
class VidEventDBConfDefaultTypeInternal;
extern VidEventDBConfDefaultTypeInternal _VidEventDBConf_default_instance_;
class VidGroup;
class VidGroupDefaultTypeInternal;
extern VidGroupDefaultTypeInternal _VidGroup_default_instance_;
class VidGroupList;
class VidGroupListDefaultTypeInternal;
extern VidGroupListDefaultTypeInternal _VidGroupList_default_instance_;
class VidHDFSConf;
class VidHDFSConfDefaultTypeInternal;
extern VidHDFSConfDefaultTypeInternal _VidHDFSConf_default_instance_;
class VidStor;
class VidStorDefaultTypeInternal;
extern VidStorDefaultTypeInternal _VidStor_default_instance_;
class VidStorList;
class VidStorListDefaultTypeInternal;
extern VidStorListDefaultTypeInternal _VidStorList_default_instance_;
class VidStorServerConf;
class VidStorServerConfDefaultTypeInternal;
extern VidStorServerConfDefaultTypeInternal _VidStorServerConf_default_instance_;
class VidStream;
class VidStreamDefaultTypeInternal;
extern VidStreamDefaultTypeInternal _VidStream_default_instance_;
class VidStreamList;
class VidStreamListDefaultTypeInternal;
extern VidStreamListDefaultTypeInternal _VidStreamList_default_instance_;
class VidTour;
class VidTourDefaultTypeInternal;
extern VidTourDefaultTypeInternal _VidTour_default_instance_;
class VidTourList;
class VidTourListDefaultTypeInternal;
extern VidTourListDefaultTypeInternal _VidTourList_default_instance_;
class VidUser;
class VidUserDefaultTypeInternal;
extern VidUserDefaultTypeInternal _VidUser_default_instance_;
class VidUserList;
class VidUserListDefaultTypeInternal;
extern VidUserListDefaultTypeInternal _VidUserList_default_instance_;
class VidView;
class VidViewDefaultTypeInternal;
extern VidViewDefaultTypeInternal _VidView_default_instance_;
class VidViewList;
class VidViewListDefaultTypeInternal;
extern VidViewListDefaultTypeInternal _VidViewList_default_instance_;
class VidViewWindow;
class VidViewWindowDefaultTypeInternal;
extern VidViewWindowDefaultTypeInternal _VidViewWindow_default_instance_;

namespace protobuf_linksystem_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_linksystem_2eproto

// ===================================================================

class LinkLoginReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LinkLoginReq) */ {
 public:
  LinkLoginReq();
  virtual ~LinkLoginReq();

  LinkLoginReq(const LinkLoginReq& from);

  inline LinkLoginReq& operator=(const LinkLoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinkLoginReq& default_instance();

  static inline const LinkLoginReq* internal_default_instance() {
    return reinterpret_cast<const LinkLoginReq*>(
               &_LinkLoginReq_default_instance_);
  }

  void Swap(LinkLoginReq* other);

  // implements Message ----------------------------------------------

  inline LinkLoginReq* New() const PROTOBUF_FINAL { return New(NULL); }

  LinkLoginReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LinkLoginReq& from);
  void MergeFrom(const LinkLoginReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LinkLoginReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string strUserName = 1;
  void clear_strusername();
  static const int kStrUserNameFieldNumber = 1;
  const ::std::string& strusername() const;
  void set_strusername(const ::std::string& value);
  #if LANG_CXX11
  void set_strusername(::std::string&& value);
  #endif
  void set_strusername(const char* value);
  void set_strusername(const char* value, size_t size);
  ::std::string* mutable_strusername();
  ::std::string* release_strusername();
  void set_allocated_strusername(::std::string* strusername);

  // string strPasswd = 2;
  void clear_strpasswd();
  static const int kStrPasswdFieldNumber = 2;
  const ::std::string& strpasswd() const;
  void set_strpasswd(const ::std::string& value);
  #if LANG_CXX11
  void set_strpasswd(::std::string&& value);
  #endif
  void set_strpasswd(const char* value);
  void set_strpasswd(const char* value, size_t size);
  ::std::string* mutable_strpasswd();
  ::std::string* release_strpasswd();
  void set_allocated_strpasswd(::std::string* strpasswd);

  // @@protoc_insertion_point(class_scope:LinkLoginReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr strusername_;
  ::google::protobuf::internal::ArenaStringPtr strpasswd_;
  mutable int _cached_size_;
  friend struct  protobuf_linksystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LinkLoginResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LinkLoginResp) */ {
 public:
  LinkLoginResp();
  virtual ~LinkLoginResp();

  LinkLoginResp(const LinkLoginResp& from);

  inline LinkLoginResp& operator=(const LinkLoginResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinkLoginResp& default_instance();

  static inline const LinkLoginResp* internal_default_instance() {
    return reinterpret_cast<const LinkLoginResp*>(
               &_LinkLoginResp_default_instance_);
  }

  void Swap(LinkLoginResp* other);

  // implements Message ----------------------------------------------

  inline LinkLoginResp* New() const PROTOBUF_FINAL { return New(NULL); }

  LinkLoginResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LinkLoginResp& from);
  void MergeFrom(const LinkLoginResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LinkLoginResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string strNonce = 1;
  void clear_strnonce();
  static const int kStrNonceFieldNumber = 1;
  const ::std::string& strnonce() const;
  void set_strnonce(const ::std::string& value);
  #if LANG_CXX11
  void set_strnonce(::std::string&& value);
  #endif
  void set_strnonce(const char* value);
  void set_strnonce(const char* value, size_t size);
  ::std::string* mutable_strnonce();
  ::std::string* release_strnonce();
  void set_allocated_strnonce(::std::string* strnonce);

  // bool bRetNonce = 2;
  void clear_bretnonce();
  static const int kBRetNonceFieldNumber = 2;
  bool bretnonce() const;
  void set_bretnonce(bool value);

  // bool bRet = 3;
  void clear_bret();
  static const int kBRetFieldNumber = 3;
  bool bret() const;
  void set_bret(bool value);

  // @@protoc_insertion_point(class_scope:LinkLoginResp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr strnonce_;
  bool bretnonce_;
  bool bret_;
  mutable int _cached_size_;
  friend struct  protobuf_linksystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LinkKeepaliveReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LinkKeepaliveReq) */ {
 public:
  LinkKeepaliveReq();
  virtual ~LinkKeepaliveReq();

  LinkKeepaliveReq(const LinkKeepaliveReq& from);

  inline LinkKeepaliveReq& operator=(const LinkKeepaliveReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinkKeepaliveReq& default_instance();

  static inline const LinkKeepaliveReq* internal_default_instance() {
    return reinterpret_cast<const LinkKeepaliveReq*>(
               &_LinkKeepaliveReq_default_instance_);
  }

  void Swap(LinkKeepaliveReq* other);

  // implements Message ----------------------------------------------

  inline LinkKeepaliveReq* New() const PROTOBUF_FINAL { return New(NULL); }

  LinkKeepaliveReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LinkKeepaliveReq& from);
  void MergeFrom(const LinkKeepaliveReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LinkKeepaliveReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 nKeepalive = 1;
  void clear_nkeepalive();
  static const int kNKeepaliveFieldNumber = 1;
  ::google::protobuf::int32 nkeepalive() const;
  void set_nkeepalive(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LinkKeepaliveReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 nkeepalive_;
  mutable int _cached_size_;
  friend struct  protobuf_linksystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LinkKeepaliveResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LinkKeepaliveResp) */ {
 public:
  LinkKeepaliveResp();
  virtual ~LinkKeepaliveResp();

  LinkKeepaliveResp(const LinkKeepaliveResp& from);

  inline LinkKeepaliveResp& operator=(const LinkKeepaliveResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinkKeepaliveResp& default_instance();

  static inline const LinkKeepaliveResp* internal_default_instance() {
    return reinterpret_cast<const LinkKeepaliveResp*>(
               &_LinkKeepaliveResp_default_instance_);
  }

  void Swap(LinkKeepaliveResp* other);

  // implements Message ----------------------------------------------

  inline LinkKeepaliveResp* New() const PROTOBUF_FINAL { return New(NULL); }

  LinkKeepaliveResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LinkKeepaliveResp& from);
  void MergeFrom(const LinkKeepaliveResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LinkKeepaliveResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 nKeepalive = 1;
  void clear_nkeepalive();
  static const int kNKeepaliveFieldNumber = 1;
  ::google::protobuf::int32 nkeepalive() const;
  void set_nkeepalive(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LinkKeepaliveResp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 nkeepalive_;
  mutable int _cached_size_;
  friend struct  protobuf_linksystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LinkListCamReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LinkListCamReq) */ {
 public:
  LinkListCamReq();
  virtual ~LinkListCamReq();

  LinkListCamReq(const LinkListCamReq& from);

  inline LinkListCamReq& operator=(const LinkListCamReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinkListCamReq& default_instance();

  static inline const LinkListCamReq* internal_default_instance() {
    return reinterpret_cast<const LinkListCamReq*>(
               &_LinkListCamReq_default_instance_);
  }

  void Swap(LinkListCamReq* other);

  // implements Message ----------------------------------------------

  inline LinkListCamReq* New() const PROTOBUF_FINAL { return New(NULL); }

  LinkListCamReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LinkListCamReq& from);
  void MergeFrom(const LinkListCamReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LinkListCamReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool bAll = 1;
  void clear_ball();
  static const int kBAllFieldNumber = 1;
  bool ball() const;
  void set_ball(bool value);

  // @@protoc_insertion_point(class_scope:LinkListCamReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool ball_;
  mutable int _cached_size_;
  friend struct  protobuf_linksystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LinkListCamResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LinkListCamResp) */ {
 public:
  LinkListCamResp();
  virtual ~LinkListCamResp();

  LinkListCamResp(const LinkListCamResp& from);

  inline LinkListCamResp& operator=(const LinkListCamResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinkListCamResp& default_instance();

  static inline const LinkListCamResp* internal_default_instance() {
    return reinterpret_cast<const LinkListCamResp*>(
               &_LinkListCamResp_default_instance_);
  }

  void Swap(LinkListCamResp* other);

  // implements Message ----------------------------------------------

  inline LinkListCamResp* New() const PROTOBUF_FINAL { return New(NULL); }

  LinkListCamResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LinkListCamResp& from);
  void MergeFrom(const LinkListCamResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LinkListCamResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .VidCameraList cList = 1;
  bool has_clist() const;
  void clear_clist();
  static const int kCListFieldNumber = 1;
  const ::VidCameraList& clist() const;
  ::VidCameraList* mutable_clist();
  ::VidCameraList* release_clist();
  void set_allocated_clist(::VidCameraList* clist);

  // @@protoc_insertion_point(class_scope:LinkListCamResp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::VidCameraList* clist_;
  mutable int _cached_size_;
  friend struct  protobuf_linksystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LinkCamReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LinkCamReq) */ {
 public:
  LinkCamReq();
  virtual ~LinkCamReq();

  LinkCamReq(const LinkCamReq& from);

  inline LinkCamReq& operator=(const LinkCamReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinkCamReq& default_instance();

  static inline const LinkCamReq* internal_default_instance() {
    return reinterpret_cast<const LinkCamReq*>(
               &_LinkCamReq_default_instance_);
  }

  void Swap(LinkCamReq* other);

  // implements Message ----------------------------------------------

  inline LinkCamReq* New() const PROTOBUF_FINAL { return New(NULL); }

  LinkCamReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LinkCamReq& from);
  void MergeFrom(const LinkCamReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LinkCamReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string strId = 1;
  void clear_strid();
  static const int kStrIdFieldNumber = 1;
  const ::std::string& strid() const;
  void set_strid(const ::std::string& value);
  #if LANG_CXX11
  void set_strid(::std::string&& value);
  #endif
  void set_strid(const char* value);
  void set_strid(const char* value, size_t size);
  ::std::string* mutable_strid();
  ::std::string* release_strid();
  void set_allocated_strid(::std::string* strid);

  // @@protoc_insertion_point(class_scope:LinkCamReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr strid_;
  mutable int _cached_size_;
  friend struct  protobuf_linksystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LinkCamResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LinkCamResp) */ {
 public:
  LinkCamResp();
  virtual ~LinkCamResp();

  LinkCamResp(const LinkCamResp& from);

  inline LinkCamResp& operator=(const LinkCamResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinkCamResp& default_instance();

  static inline const LinkCamResp* internal_default_instance() {
    return reinterpret_cast<const LinkCamResp*>(
               &_LinkCamResp_default_instance_);
  }

  void Swap(LinkCamResp* other);

  // implements Message ----------------------------------------------

  inline LinkCamResp* New() const PROTOBUF_FINAL { return New(NULL); }

  LinkCamResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LinkCamResp& from);
  void MergeFrom(const LinkCamResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LinkCamResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .VidCamera cCam = 1;
  bool has_ccam() const;
  void clear_ccam();
  static const int kCCamFieldNumber = 1;
  const ::VidCamera& ccam() const;
  ::VidCamera* mutable_ccam();
  ::VidCamera* release_ccam();
  void set_allocated_ccam(::VidCamera* ccam);

  // @@protoc_insertion_point(class_scope:LinkCamResp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::VidCamera* ccam_;
  mutable int _cached_size_;
  friend struct  protobuf_linksystem_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// LinkLoginReq

// string strUserName = 1;
inline void LinkLoginReq::clear_strusername() {
  strusername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LinkLoginReq::strusername() const {
  // @@protoc_insertion_point(field_get:LinkLoginReq.strUserName)
  return strusername_.GetNoArena();
}
inline void LinkLoginReq::set_strusername(const ::std::string& value) {
  
  strusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LinkLoginReq.strUserName)
}
#if LANG_CXX11
inline void LinkLoginReq::set_strusername(::std::string&& value) {
  
  strusername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LinkLoginReq.strUserName)
}
#endif
inline void LinkLoginReq::set_strusername(const char* value) {
  
  strusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LinkLoginReq.strUserName)
}
inline void LinkLoginReq::set_strusername(const char* value, size_t size) {
  
  strusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LinkLoginReq.strUserName)
}
inline ::std::string* LinkLoginReq::mutable_strusername() {
  
  // @@protoc_insertion_point(field_mutable:LinkLoginReq.strUserName)
  return strusername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LinkLoginReq::release_strusername() {
  // @@protoc_insertion_point(field_release:LinkLoginReq.strUserName)
  
  return strusername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LinkLoginReq::set_allocated_strusername(::std::string* strusername) {
  if (strusername != NULL) {
    
  } else {
    
  }
  strusername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), strusername);
  // @@protoc_insertion_point(field_set_allocated:LinkLoginReq.strUserName)
}

// string strPasswd = 2;
inline void LinkLoginReq::clear_strpasswd() {
  strpasswd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LinkLoginReq::strpasswd() const {
  // @@protoc_insertion_point(field_get:LinkLoginReq.strPasswd)
  return strpasswd_.GetNoArena();
}
inline void LinkLoginReq::set_strpasswd(const ::std::string& value) {
  
  strpasswd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LinkLoginReq.strPasswd)
}
#if LANG_CXX11
inline void LinkLoginReq::set_strpasswd(::std::string&& value) {
  
  strpasswd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LinkLoginReq.strPasswd)
}
#endif
inline void LinkLoginReq::set_strpasswd(const char* value) {
  
  strpasswd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LinkLoginReq.strPasswd)
}
inline void LinkLoginReq::set_strpasswd(const char* value, size_t size) {
  
  strpasswd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LinkLoginReq.strPasswd)
}
inline ::std::string* LinkLoginReq::mutable_strpasswd() {
  
  // @@protoc_insertion_point(field_mutable:LinkLoginReq.strPasswd)
  return strpasswd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LinkLoginReq::release_strpasswd() {
  // @@protoc_insertion_point(field_release:LinkLoginReq.strPasswd)
  
  return strpasswd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LinkLoginReq::set_allocated_strpasswd(::std::string* strpasswd) {
  if (strpasswd != NULL) {
    
  } else {
    
  }
  strpasswd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), strpasswd);
  // @@protoc_insertion_point(field_set_allocated:LinkLoginReq.strPasswd)
}

// -------------------------------------------------------------------

// LinkLoginResp

// string strNonce = 1;
inline void LinkLoginResp::clear_strnonce() {
  strnonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LinkLoginResp::strnonce() const {
  // @@protoc_insertion_point(field_get:LinkLoginResp.strNonce)
  return strnonce_.GetNoArena();
}
inline void LinkLoginResp::set_strnonce(const ::std::string& value) {
  
  strnonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LinkLoginResp.strNonce)
}
#if LANG_CXX11
inline void LinkLoginResp::set_strnonce(::std::string&& value) {
  
  strnonce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LinkLoginResp.strNonce)
}
#endif
inline void LinkLoginResp::set_strnonce(const char* value) {
  
  strnonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LinkLoginResp.strNonce)
}
inline void LinkLoginResp::set_strnonce(const char* value, size_t size) {
  
  strnonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LinkLoginResp.strNonce)
}
inline ::std::string* LinkLoginResp::mutable_strnonce() {
  
  // @@protoc_insertion_point(field_mutable:LinkLoginResp.strNonce)
  return strnonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LinkLoginResp::release_strnonce() {
  // @@protoc_insertion_point(field_release:LinkLoginResp.strNonce)
  
  return strnonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LinkLoginResp::set_allocated_strnonce(::std::string* strnonce) {
  if (strnonce != NULL) {
    
  } else {
    
  }
  strnonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), strnonce);
  // @@protoc_insertion_point(field_set_allocated:LinkLoginResp.strNonce)
}

// bool bRetNonce = 2;
inline void LinkLoginResp::clear_bretnonce() {
  bretnonce_ = false;
}
inline bool LinkLoginResp::bretnonce() const {
  // @@protoc_insertion_point(field_get:LinkLoginResp.bRetNonce)
  return bretnonce_;
}
inline void LinkLoginResp::set_bretnonce(bool value) {
  
  bretnonce_ = value;
  // @@protoc_insertion_point(field_set:LinkLoginResp.bRetNonce)
}

// bool bRet = 3;
inline void LinkLoginResp::clear_bret() {
  bret_ = false;
}
inline bool LinkLoginResp::bret() const {
  // @@protoc_insertion_point(field_get:LinkLoginResp.bRet)
  return bret_;
}
inline void LinkLoginResp::set_bret(bool value) {
  
  bret_ = value;
  // @@protoc_insertion_point(field_set:LinkLoginResp.bRet)
}

// -------------------------------------------------------------------

// LinkKeepaliveReq

// int32 nKeepalive = 1;
inline void LinkKeepaliveReq::clear_nkeepalive() {
  nkeepalive_ = 0;
}
inline ::google::protobuf::int32 LinkKeepaliveReq::nkeepalive() const {
  // @@protoc_insertion_point(field_get:LinkKeepaliveReq.nKeepalive)
  return nkeepalive_;
}
inline void LinkKeepaliveReq::set_nkeepalive(::google::protobuf::int32 value) {
  
  nkeepalive_ = value;
  // @@protoc_insertion_point(field_set:LinkKeepaliveReq.nKeepalive)
}

// -------------------------------------------------------------------

// LinkKeepaliveResp

// int32 nKeepalive = 1;
inline void LinkKeepaliveResp::clear_nkeepalive() {
  nkeepalive_ = 0;
}
inline ::google::protobuf::int32 LinkKeepaliveResp::nkeepalive() const {
  // @@protoc_insertion_point(field_get:LinkKeepaliveResp.nKeepalive)
  return nkeepalive_;
}
inline void LinkKeepaliveResp::set_nkeepalive(::google::protobuf::int32 value) {
  
  nkeepalive_ = value;
  // @@protoc_insertion_point(field_set:LinkKeepaliveResp.nKeepalive)
}

// -------------------------------------------------------------------

// LinkListCamReq

// bool bAll = 1;
inline void LinkListCamReq::clear_ball() {
  ball_ = false;
}
inline bool LinkListCamReq::ball() const {
  // @@protoc_insertion_point(field_get:LinkListCamReq.bAll)
  return ball_;
}
inline void LinkListCamReq::set_ball(bool value) {
  
  ball_ = value;
  // @@protoc_insertion_point(field_set:LinkListCamReq.bAll)
}

// -------------------------------------------------------------------

// LinkListCamResp

// .VidCameraList cList = 1;
inline bool LinkListCamResp::has_clist() const {
  return this != internal_default_instance() && clist_ != NULL;
}
inline void LinkListCamResp::clear_clist() {
  if (GetArenaNoVirtual() == NULL && clist_ != NULL) delete clist_;
  clist_ = NULL;
}
inline const ::VidCameraList& LinkListCamResp::clist() const {
  // @@protoc_insertion_point(field_get:LinkListCamResp.cList)
  return clist_ != NULL ? *clist_
                         : *::VidCameraList::internal_default_instance();
}
inline ::VidCameraList* LinkListCamResp::mutable_clist() {
  
  if (clist_ == NULL) {
    clist_ = new ::VidCameraList;
  }
  // @@protoc_insertion_point(field_mutable:LinkListCamResp.cList)
  return clist_;
}
inline ::VidCameraList* LinkListCamResp::release_clist() {
  // @@protoc_insertion_point(field_release:LinkListCamResp.cList)
  
  ::VidCameraList* temp = clist_;
  clist_ = NULL;
  return temp;
}
inline void LinkListCamResp::set_allocated_clist(::VidCameraList* clist) {
  delete clist_;
  clist_ = clist;
  if (clist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:LinkListCamResp.cList)
}

// -------------------------------------------------------------------

// LinkCamReq

// string strId = 1;
inline void LinkCamReq::clear_strid() {
  strid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LinkCamReq::strid() const {
  // @@protoc_insertion_point(field_get:LinkCamReq.strId)
  return strid_.GetNoArena();
}
inline void LinkCamReq::set_strid(const ::std::string& value) {
  
  strid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LinkCamReq.strId)
}
#if LANG_CXX11
inline void LinkCamReq::set_strid(::std::string&& value) {
  
  strid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LinkCamReq.strId)
}
#endif
inline void LinkCamReq::set_strid(const char* value) {
  
  strid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LinkCamReq.strId)
}
inline void LinkCamReq::set_strid(const char* value, size_t size) {
  
  strid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LinkCamReq.strId)
}
inline ::std::string* LinkCamReq::mutable_strid() {
  
  // @@protoc_insertion_point(field_mutable:LinkCamReq.strId)
  return strid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LinkCamReq::release_strid() {
  // @@protoc_insertion_point(field_release:LinkCamReq.strId)
  
  return strid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LinkCamReq::set_allocated_strid(::std::string* strid) {
  if (strid != NULL) {
    
  } else {
    
  }
  strid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), strid);
  // @@protoc_insertion_point(field_set_allocated:LinkCamReq.strId)
}

// -------------------------------------------------------------------

// LinkCamResp

// .VidCamera cCam = 1;
inline bool LinkCamResp::has_ccam() const {
  return this != internal_default_instance() && ccam_ != NULL;
}
inline void LinkCamResp::clear_ccam() {
  if (GetArenaNoVirtual() == NULL && ccam_ != NULL) delete ccam_;
  ccam_ = NULL;
}
inline const ::VidCamera& LinkCamResp::ccam() const {
  // @@protoc_insertion_point(field_get:LinkCamResp.cCam)
  return ccam_ != NULL ? *ccam_
                         : *::VidCamera::internal_default_instance();
}
inline ::VidCamera* LinkCamResp::mutable_ccam() {
  
  if (ccam_ == NULL) {
    ccam_ = new ::VidCamera;
  }
  // @@protoc_insertion_point(field_mutable:LinkCamResp.cCam)
  return ccam_;
}
inline ::VidCamera* LinkCamResp::release_ccam() {
  // @@protoc_insertion_point(field_release:LinkCamResp.cCam)
  
  ::VidCamera* temp = ccam_;
  ccam_ = NULL;
  return temp;
}
inline void LinkCamResp::set_allocated_ccam(::VidCamera* ccam) {
  delete ccam_;
  ccam_ = ccam;
  if (ccam) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:LinkCamResp.cCam)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_linksystem_2eproto__INCLUDED
